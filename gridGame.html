<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

<script>
  /*So, let's say we have a room.
[]
Each room will have four walls, a floor, and a ceiling.
Each room will also display the rooms two rooms forward.
So, a map may look like...

   y1 y2 y3 y4 y5 y6
x1 [0,0][1,0][2,0][3,0][4,0][5,0]
x2 [0,1][1,1][2,1][3,1][4,1][5,1]
x3 [X][X][X][O][O][X]
x4 [O][O][X][O][O][X]

So, this would be an array.

var tile = function(x,y,val)
{
this.x = x;
this.y = y;
this.val = val;
}

so, a textfile like
OOXOOO
OOXXXX
XXX00X
00X00X
Would be read through line by line, character by character
var rowCount = 0;
int i = 0;
the character is then assigned to a tile value in an array.
[i, rowCount, val] with val being X or O, O denoting a space the player can move in.
when we get to a newline, i is set back to 0, and rowCount is incremented by one.
Do this until we get to the end.

The "player" is instantiated. The player has a x and y value similar to a tile object. This x and y value is given a starting position.
We can imagine that the starting position is [1,1]
The game waits for user input.
Inputs UP, the game checks to see that there is a tile object at [x,y-1].
Inputs DOWN, the game checks to see that there is a tile object at [x,y+1].
Inputs RIGHT, the game checks to see that there is a tile object at [x+1,y].
Inputs LEFT, the game checks to see that there is a tile object at [x-1,y].
Assuming there IS a tile value at that value, and that tile.value = O, the player's coordinates are then updated to that position.
 --------
 -----O--
 -OOOOOO-
 ---O-O--
 -OOOO---
 --------
The map grid should always be displayed.
for every value in the map array, print out [, value, ]. Then, newline.
*/
//var testMapData = "----O-,OOOOOO,--O-O-,OOOO--";
var testMapData = "--------,-----O--,-OOOOOO-,---O-O--,-OOOO---,--------";
var currMapNum = 0;
var currMapArray = [];
function Tile(x,y,value)
{
  this.x = x,
  this.y = y,
  this.value = value
}
function Player(x,y)
{
  this.x = x;
  this.y = y;
}
var thePlayer = new Player(3,3);
var direction = "forward";
var dirDegree = 0;
function gameStart(mapData)
{
  document.getElementsByTagName('h1')[0].style.visibility = 'hidden';
  document.getElementById("displayScreenOverlay").style.visibility = 'hidden';
  document.getElementById("textBox").style.visibility = 'hidden';

  readGrid(mapData);
  displayGrid(mapData);
}

function readGrid(mapData)
{
  console.log("Read Grid Called");
  var columnCount = 0;
  var rowCount = 0;
  for (var i = 0; i < mapData.length;i++)
  {
    //mapData.charAt(i)
    if (mapData.charAt(i) === ',')
    {
      rowCount = 0;
      columnCount = columnCount + 1;
    }
    else
    {
      currMapArray.push(new Tile(rowCount,columnCount,mapData.charAt(i)));
      rowCount++;
    }
  }
}
function updatePlayer()
{
  var tempX;
  var tempY;
  if (thePlayer.x === '0')
  {
    tempX = 25;
  }
  if (thePlayer.y === '0')
  {
    tempY = 25;
  }
  else
  {
    tempX = thePlayer.x * 25;
    tempY = thePlayer.y * 25;
  }
  document.getElementById("playerArrow").style.left = tempX + 400 + "px";
  document.getElementById("playerArrow").style.top = tempY + 400 + "px";
  //Going to need to do math here. X and Y will be something like, 1, 6, 2, etc. Or even 0. We need to make that in multiples of 25 or so.
}
function displayGrid(mapData)
{
    var columnCount = 0;
    var rowCount = 0;
    var spacingColumn = 400;
    var spacingRow = 400;
    var backgroundGrid = document.createElement("div");
    //Let's put the player character on the map.
    updatePlayer();
    for (var i = 0; i < mapData.length;i++)
    {
      //mapData.charAt(i)
      if (mapData.charAt(i) === ',')
      {
        rowCount = 0;
        columnCount = columnCount + 1;
        spacingColumn +=25;
        spacingRow = 400;
      }
      else
      {
        if (mapData.charAt(i) === 'O')
        {
          var x = document.createElement("div");
          x.setAttribute('class','gridSquare');
          x.style.position="absolute";
          x.style.left=spacingRow+"px";
          x.style.top=spacingColumn+"px";
          x.style.backgroundColor="orange";
          var thisDiv = document.getElementById('backgroundGrid');
          thisDiv.appendChild(x);
        }
        else if (mapData.charAt(i) === '-')
        {
          var x = document.createElement("div");
          x.setAttribute('class','gridSquare');
          x.style.position="absolute";
          x.style.left=spacingRow+"px";
          x.style.top=spacingColumn+"px";
          x.style.backgroundColor="blue";
          var thisDiv = document.getElementById('backgroundGrid');
          thisDiv.appendChild(x);
        }
        spacingRow+= 25;
        rowCount++;
      }
    }
}
var tempX = 0;
var tempY = 0;
function rotatePlayer(input)
{
  document.getElementById("displayScreenOverlay").style.visibility = 'hidden';

  //dirDegree is 0. 0 is forward. 90 is right. 180 is back. 270 is left.
  switch (input)
  {
    case 'left':
    dirDegree = dirDegree - 90;
    break;
    case 'right':
    dirDegree = dirDegree + 90;
    break;
    case 'back':
    dirDegree = dirDegree + 180;
  }
  var x = document.getElementById('playerArrow');
  x.style.transform="rotate(" + dirDegree +"deg)";
  console.log(dirDegree);
  switch (dirDegree)
  {
    case 0:
    direction = "forward";
    break;
    case 90:
    direction = "right";
    break;
    case 180:
    direction = "backward";
    break;
    case 270:
    direction = "left";
    break;
    case 360:
    direction = "forward";
    dirDegree = 0;
    break;
    case -90:
    direction = "left";
    dirDegree = 270;
    break;
  }
  drawCamera();

}
function moveForward()
{
  console.log("Player is at " + thePlayer.x + "," + thePlayer.y);
//the game checks to see that there is a tile object at [x,y-1].

for (var i = 0; i <currMapArray.length;i++)
{

  switch (direction)
  {
    case 'forward':
    tempX = thePlayer.x;
    tempY = thePlayer.y - 1;
    break;
    case 'right':
    tempX = thePlayer.x + 1;
    tempY = thePlayer.y;
    break;
    case 'left':
    tempX = thePlayer.x - 1;
    tempY = thePlayer.y;
    break;
    case 'backward':
    tempX = thePlayer.x;
    tempY = thePlayer.y + 1;
    break;
  }
  //console.log(tempX, tempY);
  //console.log(thePlayer);

  if (currMapArray[i].value === 'O' && currMapArray[i].x === tempX && currMapArray[i].y === tempY)
  {
    //Character can move on that space.
    thePlayer.y = tempY;
    thePlayer.x = tempX;
    //console.log("The player has moved.");
    //console.log("Player is now at " + thePlayer.x + "," + thePlayer.y);
    updatePlayer();
    checkForEvent(i);

    break;
  }
  else
  {
    //console.log("The way ahead is blocked.");
  }
}
drawCamera();

}
//We need a function for what direction the player is facing. The player has a default of facing Up.
function drawCamera()
{
  var x = thePlayer.x;
  var y = thePlayer.y;
  console.log(thePlayer);
  var playerTile;
  for (var i = 0; i <currMapArray.length;i++)
  {
    if (currMapArray[i].x === x && currMapArray[i].y === y)
    {
      console.log ("have tile" + i);
      playerTile = i;
    }
  }
  var aVal;
  var bVal;
  var cVal;
  var dVal;
  var eVal;
  var fVal;
  var gVal;
  var iVal;


  var zVal;


  //For facing forward, the values are -13, -12, -11, -7, -6, -5, -1, null, +1
  // Facing left, the values are 4,-2,-8,5,-1,-7,6,null,-6
  // Facing right, the values are -4,2,8,-5,1,7,-6,null,6
  // Facing backwards, the values are 13,12,11,7,6,5,1,null,-1
  switch (direction)
  {
    case 'forward':
    aVal = -17; bVal = -16; cVal = -15; dVal = -9; eVal = -8; fVal = -7; gVal = -1; iVal = 1; zVal = -24;
    break;
    case 'backward':
    aVal = 17; bVal = 16; cVal = 15; dVal = 9; eVal = 8; fVal = 7; gVal = 1; iVal = -1; zVal = 24;
    break;
    case 'left':
    aVal = 6; bVal = -2; cVal = -10; dVal = 7; eVal = -1; fVal = -9; gVal = 8; iVal = -8; zVal = -3;
    break;
    case 'right':
    aVal = -6; bVal = 2; cVal = 10; dVal = -7; eVal = 1; fVal = 9; gVal = -8; iVal = 8; zVal = 3;
    break;
  }

    var aFree;
    var bFree;
    var cFree;
    var dFree;
    var eFree;
    var fFree;
    var gFree;
    var iFree;
    var zFree;

    if (currMapArray[playerTile+aVal])
    {
      if (currMapArray[playerTile+aVal].value === 'O')
      {
        aFree = true;
      }
      else
      {
        aFree = false;
      }
    }

    else
    {
      aFree = false;
    }
    if (currMapArray[playerTile+bVal])
    {
      if (currMapArray[playerTile+bVal].value === 'O')
      {
        bFree = true;
      }
      else
      {
        bFree = false;
      }
    }

    else
    {
      bFree = false;
    }
    if (currMapArray[playerTile+cVal])
    {
      if (currMapArray[playerTile+cVal].value === 'O')
      {
        cFree = true;
      }
      else
      {
        cFree = false;
      }
    }
    else
    {
      cFree = false;
    }

    if (currMapArray[playerTile+dVal])
    {
      if (currMapArray[playerTile+dVal].value === 'O')
      {
        dFree = true;
      }
      else
      {
        dFree = false;
      }
    }
    else
    {
      dFree = false;
    }


    if (currMapArray[playerTile+eVal])
    {
      if (currMapArray[playerTile+eVal].value === 'O')
      {
        eFree = true;
      }
      else
      {
        eFree = false;
      }
    }
    else
    {
      eFree = false;
    }

    if (currMapArray[playerTile+fVal])
    {
      if (currMapArray[playerTile+fVal].value === 'O')
      {
        fFree = true;
      }
      else
      {
        fFree = false;
      }
    }
    else
    {
      fFree = false;
    }

    if (currMapArray[playerTile+gVal])
    {
      if (currMapArray[playerTile+gVal].value === 'O')
      {
        gFree = true;
      }
      else
      {
        gFree = false;
      }
    }
    else
    {
      gFree = false;
    }

    if (currMapArray[playerTile+iVal])
    {
      if (currMapArray[playerTile+iVal].value === 'O')
      {
        iFree = true;
      }
      else
      {
        iFree = false;
      }
    }
    else
    {
      iFree = false;
    }
    if (currMapArray[playerTile+zVal])
    {
      if (currMapArray[playerTile+zVal].value === 'O')
      {
        console.log("it tru");
        zFree = true;
      }
      else
      {
        zFree = false;
      }
    }
    else
    {
      zFree = false;
    }


  if (!bFree && !dFree && eFree && !fFree && gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndFork.png";
  }

  else if (!eFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Null.png";
  }

  else if (!bFree && !cFree && !dFree && eFree && !fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEnd1.png";
  }

  else if (!aFree && bFree && !dFree && eFree && !fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEnd2.png";
  }
  else if (!aFree && !bFree && !dFree && eFree && !fFree && gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndFork.png";
  }

  else if (!aFree && bFree && !dFree && eFree && !fFree && gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndL.png";
  }
  else if (aFree && !bFree && !cFree && !dFree && eFree && !fFree && gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndForkL.png";
  }
  else if (!aFree && bFree && !cFree && !dFree && eFree && !fFree && !gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndR.png";
  }
  else if (!aFree && bFree && !dFree && eFree && fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndRFork.png";
  }
  else if (!aFree && !bFree && !dFree && !eFree && !fFree && gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0.png";
  }
  else if (!aFree && !bFree && !dFree && !eFree && !fFree && gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Left.png";
  }
  else if (!aFree && !bFree && !dFree && !eFree && !fFree && !gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Right.png";
  }
  else if (!aFree && !bFree && dFree && eFree && fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/forkAhead.png";
  }


  else if (aFree && bFree && cFree && !dFree && eFree && !fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/forkAhead2.png";
  }
  else if (aFree && bFree && cFree && !dFree && eFree && !fFree && gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/forkAheadI.png";
  }
  else if (!aFree && !bFree && dFree && eFree && !fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/leftAhead.png";
  }
  else if (aFree && bFree && !dFree && eFree && !fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/leftAhead2.png";
  }
  else if (aFree && bFree && !dFree && eFree && !fFree && gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/leftAheadFork2.png";
  }
  //LongLFork and longRFork need to be added
  else if (!aFree && !bFree && !dFree && eFree && fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/rightAhead.png";
  }
  else if (!aFree && bFree && cFree && !dFree && eFree && !fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/rightAhead2.png";
  }
  else if (!aFree && bFree && cFree && !dFree && eFree && !fFree && gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/rightAheadFork2.png";
  }
  else if (!aFree && bFree && !cFree && dFree && eFree && fFree && !gFree && !iFree && !zFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/longMidFork.png";
  }
  else if (aFree && bFree && cFree && !dFree && eFree && !fFree && !gFree && iFree && zFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/longerMidForkR.png";
  }
  else if (aFree && bFree && cFree && !dFree && eFree && !fFree && !gFree && !iFree && zFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/longerMidFork.png";
  }

  else if (!dFree && !eFree && !fFree && iFree && !gFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Right.png";
  }
  else if (!dFree && !eFree && !fFree && !iFree && gFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Left.png";
  }
  else if (bFree && eFree && fFree && !dFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndRFork.png";
  }
  else if (bFree && eFree && !fFree && dFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/deadEndLFork.png";
  }
  else if (!eFree && !iFree && gFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Left.png";
  }
  else if (!eFree && iFree && gFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0.png";
  }
  else if (!eFree && !gFree && iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/fork0Right.png";
  }
  else if (bFree && zFree && eFree && dFree && fFree && !gFree && !iFree)
  {
    document.getElementById("displayScreen").src = "gridGameImg/longerMidFork.png";

  }
  else
  {
    document.getElementById("displayScreen").src = "gridGameImg/null.png";
  }

}

var doneVal = 0;
var currEvent;
function checkForEvent(tileID)
{
  console.log("Check for event at tile" + tileID);
  if (currMapNum === 0)
  {
    document.getElementById("displayScreenOverlay").style.visibility = 'hidden';

    switch (tileID)
    {
      case 17:
      if (direction === 'left')
      {
        document.getElementById("displayScreenOverlay").src = "gridGameImg/doittoem.png";
        document.getElementById("displayScreenOverlay").style.visibility = 'visible';
        currEvent = 17;
      }
      break;
      case 33:
      {
        document.getElementById("displayScreenOverlay").src = "gridGameImg/objects/radio.png";
        document.getElementById("displayScreenOverlay").style.visibility = 'visible';
        currEvent = 33;

      }
    }



}
}
function loadNewMap()
{
  $('.gridSquare').remove();
  testMapData = "--------,-----O--,-OOOOOO-,-OOO-O--,-OOOOOO-,-------";
  gameStart(testMapData);
  console.log("loaded new map");
}
var isEnable = true;
function displayText(textString)
{
  document.getElementById("textDisplay").innerHTML = '';
  document.getElementById("textBox").style.visibility = 'visible';

  document.getElementById("textDisplay").style.visibility = 'visible';
  //document.getElementById("buttonLeft").disabled = true;
  //document.getElementById("buttonRight").disabled = true;
  //document.getElementById("buttonUp").disabled = true;
  //document.getElementById("buttonDown").disabled = true;
  isEnable = false;


  var i = 0;
    var interval = setInterval(function(){
        document.getElementById("textDisplay").innerHTML += textString.charAt(i);
        i++;
        console.log(i);
        if (i > textString.length){
            clearInterval(interval);
        }
    }, 50);





doneVal++;
}

function changeText(thisChar)
{
  console.log("b");
}
//Called when A button is pressed. I'm going to have to implement state handlers so that this isn't being called in the middle of battle.
function aFunc()
{
  console.log("A clicked");
  switch (currEvent)
  {
    case 17:
    console.log("Here1");
    console.log(doneVal);
    if (doneVal === 0)
    {
      displayText("You know I HAD to do it to em.");
    }
    else if (doneVal === 1)
    {
      console.log("here2");
      displayText("I gotta do it to em.");
    }
    else if (doneVal === 2)
    {
      document.getElementById("textDisplay").style.visibility = 'hidden';
      document.getElementById("displayScreenOverlay").style.visibility = 'hidden';
      document.getElementById("textBox").style.visibility = 'hidden';

      isEnable = true;

      doneVal = 0;
    }
    break;
    case 33:
    if (doneVal === 0)
    {
      displayText("An old record player.");
    }
    else if (doneVal === 1)
    {
      console.log("here2");
      displayText("The arm of the machine is mangled and twisted.");
    }
    else if (doneVal === 2)
    {
      document.getElementById("textDisplay").style.visibility = 'hidden';
      document.getElementById("displayScreenOverlay").style.visibility = 'hidden';
      document.getElementById("textBox").style.visibility = 'hidden';

      isEnable = true;

      doneVal = 0;
    }

  }
}
var currentState;
//Changes the currentState. States are map and battle

document.addEventListener('keydown', logKey);

//Uses key inputs instead of buttons.
function logKey(e) {
  if (e.code === 'ArrowRight' && isEnable)
  {
    rotatePlayer('right');
  }
  if (e.code === 'ArrowLeft' && isEnable)
  {
    rotatePlayer('left');
  }
  if (e.code === 'ArrowUp' && isEnable)
  {
    moveForward();
  }
  if (e.code === 'ArrowDown' && isEnable)
  {
    rotatePlayer('back')
  }
  if (e.code === 'KeyZ')
  {
    aFunc();
  }
  if (e.code === 'KeyX')
  {
  }
  else
  {
    console.log("clickie");
  }
}

</script>


<!--
iPhone X proportions are 375 by 812
Avg screen is 1024x768
-->
<style>
  .square
  {
    height: 200px;
    width: 300px;
    background-color: grey;
    position: absolute;
    top: 300px;
    right: 350px;
  }


  .trapezoidLeft {
	border-bottom: 100px solid #555;
	border-left: 75px solid transparent;
	border-right: 75px solid transparent;
	height: 0;
	width: 200px;
    transform: rotate(90deg);
    position: absolute;
    top: 350px;
    right: 525px;
}
.trapezoidRight {
  border-bottom: 100px solid #555;
	border-left: 75px solid transparent;
	border-right: 75px solid transparent;
	height: 0;
	width: 200px;
    transform: rotate(-90deg);
    position: absolute;
    top: 350px;
    right: 125px;
}
.trapezoidBottom {
border-bottom: 75px solid #4d4d4d;
border-left: 100px solid transparent;
border-right: 100px solid transparent;
width: 300px;
  position: absolute;
  top: 500px;
  right: 250px;
  color: black;
}
.trapezoidCeiling {
border-bottom: 75px solid #4d4d4d;
border-left: 100px solid transparent;
border-right: 100px solid transparent;
width: 300px;
  position: absolute;
  transform: rotate(180deg);
  top: 225px;
  right: 250px;
  color: black;
}
.gridSquare
{
  border: 2px solid black;
  width: 20px;
  height: 20px;
  background-color: orange;
  z-index: 1;
}
#playerArrow {
  color: red;
  position: absolute;
	border-left: 10px solid transparent;
	border-right: 10px solid transparent;
	border-bottom: 15px solid red;
  z-index: 3;
}
#displayScreen
{
  position: fixed;
  top: 5%;
  left: 35%;
  z-index: 1;
}
#displayScreenOverlay
{
  position: fixed;
  top: 20%;
  left: 50%;
  width: 20%;
  height: 35%;
  z-index: 2;
}
.button {
  background-color: grey; /* Green */
  border: none;
  color: white;
  padding-bottom: 5px;
  padding-left: 12px;
  padding-right: 12px;
  border-radius: 50%;
  text-align: center;
  display: inline-block;
  font-size: 30px;
  margin: 4px 2px;
  cursor: pointer;
}
.buttonb2
{
  background-color: grey; /* Green */
  border: none;
  color: white;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-radius: 50%;
  text-align: center;
  display: inline-block;
  font-size: 30px;
  margin: 4px 2px;
  cursor: pointer;
}
.button3
{
  background-color: grey; /* Green */
  border: none;
  color: white;
  padding-bottom: 7px;
  padding-left: 12px;
  padding-right: 12px;
  border-radius: 50%;
  text-align: center;
  display: inline-block;
  font-size: 30px;
  margin: 4px 2px;
  cursor: pointer;
}
.content
{
  max-width: 600px;
  margin: auto;
  height: 600px;
  padding: 20px;
  background-color: black;
}
#buttonDiv
{
  padding-top: 390px;
  padding-left: 70px;
  max-height: 150px;
  max-width: 250px;
}
#textDisplay
{
  font-family: 'Roboto', sans-serif;
  color: white;
  font-size: 22px;
  position: fixed;
  z-index: 99;
  top: 53%;
  left: 36%;
}
#textBox
{
  position: fixed;
  z-index: 5;
  top: 54%;
  left: 35%;
}
</style>
<head>
  <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
  </head>
<body onload ="gameStart(testMapData)">
<div class="content">
  <div style="padding-top:1px;">

  </div>
  <h1 id="textDisplay">TestText</h1>
  <img id="textBox" src="gridGameImg/textBox.png"></img>
  <img id="displayScreen" src="gridGameImg/null.png"></img>
  <img id="displayScreenOverlay" src="gridGameImg/doittoem.png"></img>
<!--
    <div id="buttonDiv">
    <div>
      <button onclick= "moveForward()" class="button"id="buttonUp">↑</button>
      <button onclick= "rotatePlayer('back')" class="button" id="buttonDown">↓</button>
      <button style="margin-left: 75px;" class="button3">B</button>
      <button onclick= "rotatePlayer('left')" class="buttonb2"id="buttonLeft">←</button>
      <button onclick= "rotatePlayer('right')" class="buttonb2"id="buttonRight">→</button>
      <button style="margin-left:50px;"class="button3"id="aButton" onclick="aFunc()">A</button>
      </div>
</div>
-->
  <div id="backgroundGrid" style="padding-top:100px;">
    <div id="playerArrow" />
    </div>
    </div>
</body>
